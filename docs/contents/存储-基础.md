# 基础

## 数据库

数据库（Database，简称DB）是按照数据结构来组织、存储和管理数据的仓库。它是信息系统的一个核心技术，研究如何组织和存储数据，如何高效地获取和处理数据。数据库能够存储大量结构化和非结构化的数据，包括文本、数字、图像、音频等各种类型的数据，是计算机系统中最重要的组件之一，被广泛用于各种应用程序和业务领域。

### 类型与模型

数据库有多种类型，每种类型都有其特定的使用场景和优势，常见的有以下几种：

1. **关系型数据库（RDBMS）**：根据“关系模型”来组织和管理数据。在关系型数据库中，数据被组织成一个或多个表，每个表中包含的是相互关联的数据。关系型数据库使用结构化查询语言（SQL）来管理和操作数据。常见的关系型数据库有Oracle、MySQL、SQL Server等。
2. **非关系型数据库（NoSQL）**：不使用传统的关系型数据库模型，而是使用键值对、文档、列族等方式来组织数据。非关系型数据库具有高度的可扩展性和灵活性，适用于大数据和实时应用场景。常见的非关系型数据库有MongoDB、Redis、Cassandra等。
3. **对象型数据库**：以对象为中心，可以直接支持面向对象的数据模型的数据库。在对象型数据库中，数据以对象的形式存在，对象的属性用于描述数据，对象的方法用于处理数据。常见的对象型数据库有Zope Object Database等。
4. **层次数据库**：使用树状结构来组织数据，其中每个节点可以有多个子节点。它适用于需要处理具有父子关系的数据，如组织结构或产品分类。常见的层次数据库有IMS等。
5. **网络数据库**：使用复杂的网络结构来组织数据，其中一个节点可以与多个节点相连。这种数据库类型适用于需要处理复杂的关联关系的场景，如科学研究或工程设计。常见的网络数据库有IDMS等。

### 核心要素

数据库技术的根本目标是要解决数据的共享问题，数据库通常包括以下几个核心要素：

1. **数据结构**：主要用于描述数据的静态特征，包括数据的结构和数据间的联系。
2. **数据操作**：指在数据库中能够进行的查询、修改、删除现有数据或增加新数据的各种数据访问方式，并且包括数据访问相关的规则。
3. **数据完整性约束**：由一组完整性规则组成，保证数据库中数据的正确、有效性和完整性。

### 应用场景

- **业务运营**：数据库主要用于支持企业的日常业务运营活动，如客户关系管理、供应链管理、人力资源管理等。
- **事务处理**：数据库能够高效地处理大量的事务操作，如订单的创建、修改和删除等。
- **数据检索**：数据库提供了高效的数据检索功能，支持用户根据特定的条件快速查找所需的数据。



## 数据仓库

数据仓库（Data Warehouse, DW）

- 定义：数据仓库是一个面向主题的、集成的、相对稳定的、反映历史变化的数据集合，用于支持管理决策。
- 目的：数据仓库的主要目的是为企业的决策分析提供数据支持，它存储的是大量的历史数据，用于进行趋势分析、报表生成等决策支持活动。

### 特点

- **面向主题**：数据仓库中的数据是按照主题进行组织的，每个主题对应一个宏观分析领域。
- **集成性**：数据仓库中的数据是从多个异构数据源中抽取、转换和集成的，以保持数据的一致性和完整性。
- **稳定性**：相对稳定是指数据仓库中的数据主要用于查询和分析，而不是频繁地更新。一旦数据进入数据仓库，通常会在较长时间内保持不变，除非有新的数据补充进来或者需要对历史数据进行修正。
- **反映历史变化**：反映历史变化表示数据仓库能够保存不同时间点的数据，以便分析数据随时间的变化趋势。例如，企业可以通过数据仓库中的历史销售数据，分析每个季度、每年的销售增长或下降情况。

### 应用场景

- **决策支持**：数据仓库主要用于支持企业的决策分析活动，如趋势预测、业务报表生成等。
- **数据挖掘**：数据仓库中的数据可以用于数据挖掘和机器学习等高级分析活动。
- **数据集成**：数据仓库可以集成来自多个异构数据源的数据，以提供全面的数据分析支持。

### 技术实现

- **ETL过程**：数据仓库的ETL（Extract, Transform, Load）过程负责将数据从多个数据源抽取、转换并加载到数据仓库中。
- **数据建模**：数据仓库通常采用星型或雪花型结构来优化查询性能，这些结构使得数据仓库能够处理复杂的、多维度的查询。
- **OLAP服务器**：数据仓库通常配备OLAP（Online Analytical Processing）服务器，以提供多维度分析能力。

### 数仓与数据库的区别

1. **设计目的**
   - 数据库：主要用于高效存储和管理数据，面向事务处理，重点在日常操作和数据完整性。
   - 数据仓库：用于支持决策分析，是面向主题、集成、稳定且反映历史变化的数据集合，面向分析处理。
2. **数据特点**
   - 数据库：存储当前业务数据，结构固定，多为关系模型。
   - 数据仓库：包含当前和历史数据，结构更灵活，有多种数据格式。
3. **数据更新频率**
   - 数据库：更新频繁，每次涉及少量记录。
   - 数据仓库：更新不频繁，多为批量更新，涉及大量数据。
4. **用户群体和使用方式**
   - 数据库：主要是业务操作人员，通过应用程序或简单查询语句操作。
   - 数据仓库：主要是分析师和管理者，使用分析工具和技术来挖掘价值。

### 数仓ETL

数据仓库的ETL是指将数据从来源端经过抽取（Extract）、转换（Transform）、加载（Load）至目的端的过程。它是数据仓库的核心组成部分，也是商业智能（BI）项目的重要环节。

#### 步骤

##### 一、数据抽取（Extract）

数据抽取是ETL过程的第一步，主要是从多个源系统中获取数据。这些数据源可以是关系型数据库、非关系型数据库、文件系统、Web服务等。数据抽取的过程中，需要考虑数据的完整性和一致性，以确保数据能够准确反映源系统的实际情况。数据抽取的方法包括全量提取、增量提取和基于事件的提取。

1. **全量提取**：每次提取所有数据，适用于数据量较小且变动不频繁的场景。优点是操作简单，缺点是数据量较大时，提取过程会占用大量的资源，影响系统性能。
2. **增量提取**：只提取新增或发生变化的数据，适用于数据量大且经常变动的场景。这种方法能够减少数据提取和加载的时间，提高ETL过程的效率。
3. **基于事件的提取**：在特定事件发生时才进行数据提取，适用于实时数据处理需求较高的场景。

##### 二、数据转换（Transform）

数据转换是ETL过程的第二步，主要目的是将提取的数据转换为符合目标数据仓库要求的格式和结构。数据转换的过程包括数据类型转换、数据清洗、数据集成、数据聚合等。

1. **数据类型转换**：将源数据的类型转换为目标数据仓库所需的类型，如将字符串类型的数据转换为日期类型或数值类型。
2. **数据清洗**：对提取的数据进行清理，去除重复数据、缺失数据和错误数据。数据清洗的目的是提高数据的质量，确保数据的准确性和完整性。清洗过程包括数据去重、数据填充、数据校正等。
3. **数据集成**：将来自多个源系统的数据进行整合，形成一个统一的数据视图。数据集成的目的是消除数据孤岛，实现数据的集中管理和共享。
4. **数据聚合**：对提取的数据进行汇总和统计，生成汇总数据和统计指标。数据聚合的目的是提高数据的可读性和分析性，支持数据分析和决策。

##### 三、数据加载（Load）

数据加载是ETL过程的第三步，主要目的是将转换后的数据加载到目标数据仓库中。数据加载的过程包括数据插入、数据更新、数据删除等。

1. **数据插入**：将新的数据插入到目标数据仓库的表中。数据插入的目的是将提取的数据存储在数据仓库中，以便后续的查询和分析。
2. **数据更新**：对目标数据仓库中的数据进行更新，反映源数据的变化。数据更新的目的是保持数据的一致性和最新性。
3. **数据删除**：从目标数据仓库中删除不再需要的数据。数据删除的目的是释放存储空间，提高数据的管理效率。

在数据加载过程中，还需要考虑数据的加载策略和性能优化。数据加载策略包括全量加载和增量加载。为了提高数据加载的性能，可以采用分区加载、批量加载、并行加载等技术。



# SQL

## 概述

SQL，全称Structured Query Language，即结构化查询语言，是一种用于管理和操作关系型数据库的标准编程语言。

### 定义与功能

SQL是一种专门用于与关系型数据库进行通信的语言。它允许用户执行数据的存储、查询、更新和管理等操作。SQL的主要功能包括数据定义、数据操作、数据查询和数据控制。

1. **数据定义**：用于定义数据库中的数据结构，如创建、修改和删除数据库对象（如表、视图、索引等）。
2. **数据操作**：用于向数据库中插入、更新和删除数据。
3. **数据查询**：用于从数据库中检索数据，这是SQL最常用的功能之一。
4. **数据控制**：用于设置数据库用户的权限和安全性。

### 发展历史

SQL语言最初由Boyce和Chamberlin在1974年提出，并首先在IBM公司研制的关系数据库系统System R上实现。随后，SQL逐渐成为关系型数据库管理系统的标准语言。在1986年，SQL成为ANSI（American National Standards Institute，美国国家标准化组织）的一项标准，并在1987年成为国际标准化组织（ISO）的标准。

### 特点

1. **统一性**：SQL为所有关系型数据库提供了统一的查询和操作语言。
2. **灵活性**：SQL允许用户以多种方式查询和操作数据，包括简单的查询和复杂的计算。
3. **安全性**：通过数据控制功能，SQL可以确保数据库的安全性和完整性。
4. **嵌入式**：SQL语句可以嵌入到高级语言程序中，供程序员设计程序时使用。

### 分类

1. **数据定义语言（DDL）**：用于定义数据库中的数据结构，如CREATE、DROP、ALTER等命令。
2. **数据操作语言（DML）**：用于对数据库中的数据进行插入、更新和删除操作，如INSERT、UPDATE、DELETE等命令。
3. **数据查询语言（DQL）**：用于从数据库中检索数据，主要是SELECT命令。
4. **数据控制语言（DCL）**：用于设置数据库用户的权限和安全性，如GRANT、REVOKE等命令。

### 应用场景

SQL广泛应用于各种领域，包括但不限于：

1. **数据存储和管理**：SQL数据库提供了一个结构化的环境来存储大量的数据，并确保数据的一致性和完整性。
2. **数据分析和报告**：通过复杂的SQL查询，用户可以从数据库中提取有价值的信息，并生成各种报告。
3. **应用程序开发**：现代的应用程序通常需要一个后端数据库来存储和管理数据，SQL数据库为此提供了强大的支持。
4. **商业智能和决策支持**：SQL数据库在BI工具中扮演着核心角色，通过ETL过程将数据从各种源头导入数据库，再通过复杂的查询和分析生成可视化报表和仪表盘。



## 实践

### 设计原则

- **尽可能使用 not null**
  
  非null字段的处理要比null字段的处理高效些！且不需要判断是否为null。
  
  null在MySQL中，不好处理，存储需要额外空间，运算也需要特殊的运算符。如select null = null和select null <> null（<>为不等号）有着同样的结果，只能通过is null和is not null来判断字段是否为null。
  
  如何存储？MySQL中每条记录都需要额外的存储空间，表示每个字段是否为null。因此通常使用特殊的数据进行占位，比如int not null default 0、string not null default ‘’

- **复合索引只对第一个字段有效**
  
  建立复合索引：
  
  ```sql
  alter table person add index(first_name,last_name);
  ```
  
  其原理就是将索引先按照从first_name中提取的关键字排序，如果无法确定先后再按照从last_name提取的关键字排序，也就是说该索引表只是按照记录的first_name字段值有序。
  
  因此select * from person where first_name = ?是可以利用索引的，而select * from person where last_name = ?无法利用索引。



### 多表[查询](https://www.cnblogs.com/fnlingnzb-learner/p/6343828.html)

**内连接：内连接是子运用比较运算符设置连接条件，只返回满足连接条件的数据行，是将交叉连接生成的结果集按照连接条件进行筛选后形成的。**

内连接（INNER JOIN）：有两种，显式的和隐式的，返回连接表中符合连接条件和查询条件的数据行。（所谓的链接表就是数据库在做查询形成的中间表）

例如：下面的语句3和语句4的结果是相同的。

**语句3：隐式的内连接，没有INNER JOIN，形成的中间表为两个表的笛卡尔积。**

```sql
SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME
FROM CUSTOMERS C,ORDERS O
WHERE C.ID=O.CUSTOMER_ID;
```

**语句4：显示的内连接，一般称为内连接，有INNER JOIN，形成的中间表为两个表经过ON条件过滤后的笛卡尔积。**

```sql
SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME
FROM CUSTOMERS C INNER JOIN ORDERS O ON C.ID=O.CUSTOMER_ID;
```

 自然连接（NATURAL INNER JOIN）也属于内连接：与等值连接（隐式内连接）相同，都是在连接条件中使用比较运算符，但结果集中不包括重复字段。（这种连接查询没有存在的价值。因为：自然连接无需指定连接列，SQL会检查两个表中是否相同名称的列，且假设他们在连接条件中使用，并且在连接条件中仅包含一个连接列。不允许使用ON语句，不允许指定显示列，显示列只能用*表示（ORACLE环境下测试的）。对于每种连接类型（除了交叉连接外），均可指定NATURAL。）

 等值连接：R.A=S.A

| R.A | B   | C   | S.A | D   |
| --- | --- | --- | --- | --- |
| 1   | 2   | 3   | 1   | 2   |

自然连接：R NATURAL INNER JOIN S

| R.A | B   | C   | D   |
| --- | --- | --- | --- |
| 1   | 2   | 3   | 2   |

### SQL函数

**length()**

```sql
-- 查询字段长度=1的数据
select * from table where length(column)=1;
```

**replace()**

```sql
-- 替换
update table set column=replace(column,'我','*')
```

**IF表达式**

```sql
IF(expr1,expr2,expr3)
```

> 如果 expr1 是**TRUE** (expr1 <> 0 and expr1 <> NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。

**count()**

COUNT() 函数返回匹配指定条件的行数。COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目。

```sql
SELECT COUNT(DISTINCT column_name) FROM table_name;
```

### 空值比较

<>'' 和 <>' ' 对于不同数据库是不一样的，在oracle数据库中，<>''查询不到数据，除非跟上 or ... is not null

### IN和EXISTS效率详解

- **`IN` 子查询**：适用于**子查询结果集较小**且主查询中的列有索引的情况。
  
  如果子查询的结果集较小，`IN` 子查询可能更快，因为子查询结果集可以很快构建并存储。

- **`EXISTS` 子查询**：适用于**子查询结果集较大**或子查询较慢，且只需要判断是否存在满足条件的记录的情况。
  
  如果子查询的结果集较大，`EXISTS` 子查询可能更快，因为不需要构建完整的子查询结果集。

```sql
select * from T1 where exists(select 1 from T2 where T1.a=T2.a);
```

T1数据量小而T2数据量非常大时，T1<<T2

```sql
select * from T1 where T1.a in (select T2.a from T2);
```

T1数据量非常大而T2数据量小时，T1>>T2

### 关系数据库事务的ACID特性

**原子性（Atomicity）：**

即事务是数据库的不可分割单元，事务内的操作要么全部执行完成，如果有一个失败，则事务内的操作全部失败。

**一致性（consistency）：**

即事务必须使数据库从一个一致性状态变成另外一个一致性状态，原子性和一致性是密切相关的。

**隔离性（isolation）：**

即事务和事务之间没有影响关系，这个事务的执行不能被其它事务所干扰。并发执行的各个事务不能互相干扰，具有隔离性。

**持久性（durability）：**

如果事务对数据库进行了操作并进行了提交，则数据库对此的改变应该具有持久性，不能因为其它操作或者数据库的损坏而丢失数据。故事务应该具有持久性。

### 事务的[隔离级别](https://blog.csdn.net/u012012621/article/details/50787576)

1. **读未提交**
   
   在该隔离级别，所有事务都可以看到其它事务未提交的内容数据，此隔离级别没有解决任何并发问题，故在应用场景中不常用。

2. **读已提交**
   
   在该隔离级别，一个事务只能读取其它事务已经提交的内容数据，此隔离级别解决了脏读，但没有解决不可重复读和幻读，是**ORACLE**的默认隔离级别。

3. **可重复读**
   
   在该隔离级别，能保证一个事务之间的多个实例在并发能读取同一数据，即保证在同一个事务中多次读取同样数据的结果是一样的。此隔离级别解决了脏读和不可重复读，是**MYSQL**的默认级别。

4. **串行化**
   
   这是最高的隔离级别，在此隔离级别，事务事务之间只能顺序执行，使之没有任何冲突，也就 是从而解决了脏读，不可重复读和幻读，此隔离级别效率较慢，并且有较多的超时现象。

**事物的隔离级别用以解决在并发的情况下，事务产生的以下问题：**

**更新丢失：**

两个事务都对同一行数据进行更新，但是第二组事务因为某种原因而中途即退出，所以导致两个事务对数据的修改都失败。

**脏读：**

一个事务读取了另一个事务没有提交的数据叫做脏读。例如，A事务正在修改数据，但是还没有修改完毕进行提交，这个过程中B事务对这条数据进行了读取操作，B事务产生了脏读。

**不可重复读：**

一个事务在对数据库进行了再次查询操作，但是即产生了不同结果，数据本身产生了变化，此为不可重复读。例如，A事务第一次查询此条数据，而B事务对此条数据进行了修改，而后A事务又再次查询了此条数据，却不是预期的结果，不能重复读取。故不可重复读（进行了UPDATE操作）。

**幻读：**

一个事务在对数据库进行了再次查询操作，但是却产生了不同结果，或是少了数据行，或是多了未知数据行，此为幻读（一定要明白是数据条数，不是数据本身）。例如，A事务第一次查询此条数据，而B事务对此表进行了插入或者删除操作，而后A事务又再次查询了此表，却产生了与上次不一样的条数记录。故为幻读（进行了INSERT/DELETE操作）。

### 聚集索引与非聚集索引

[索引](https://www.cnblogs.com/s-b-b/p/8334593.html)是关系型数据库中给数据库表中一列或多列的值排序后的存储结构，SQL的主流索引结构有B+树以及Hash结构，聚集索引以及非聚集索引用的是B+树索引。这篇文章会总结SQL Server以及MySQL的InnoDB和MyISAM两种SQL的索引。

SQL Sever索引类型有：唯一索引，主键索引，聚集索引，非聚集索引。

MySQL 索引类型有：唯一索引，主键（聚集）索引，非聚集索引，全文索引。

- 聚集（clustered）索引：也叫聚簇索引。数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。

- 非聚集（unclustered）索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

在[SQL Server](https://www.etuan.com/zx/116-144049.html)中，数据是按页进行存放的。而为表加上聚集索引后，SQL Server对于数据的查找就是按照聚集索引的列作为关键字进行了。因此对于聚集索引的选择对性能的影响就变得十分重要了。本文从旨在从性能的角度来谈聚集索引的选择，但这仅仅是从性能方面考虑。对于有特殊业务要求的表，则需要按实际情况进行选择。聚集索引所在的列或列的组合最好是唯一的 这个原因需要从数据的存放原理来谈。在SQL Server中，数据的存放方式并不是以行(Row)为单位，而是以页为单位。因此，在查找数据时，SQL Server查找的最小单位实际上是页（页的大小是8K）。也就是说即使你只查找一行很小的数据，SQL Server也会将整个页查找出来，放到缓冲池中。

### SQL语句[优化](https://zhuanlan.zhihu.com/p/72071609)

1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

2.应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

3.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描

### left join on 后 and 和 where 的区别

**[优先级](https://blog.csdn.net/ahwsk/article/details/82886732)**：

> 两者放置相同条件，之所以可能会导致结果集不同，就是因为优先级。on的优先级是高于where的。

首先明确两个概念：

- LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行。
- 数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。

在left join下，两者的区别：

- on是在生成临时表的时候使用的条件，不管on的条件是否起到作用，都会返回左表 (table_name1) 的行。
- where则是在生成临时表之后使用的条件，此时已经不管是否使用了left join了，只要条件不为真的行，全部过滤掉。

### count语句

#### count(*) 、count(1)、 count(列名) 的区别

- **执行效果**
  
  count(*) 、count(1) 在统计时不会忽略列值为null的数据。
  
  count(列名) 在统计时，会忽略列值为空的数据，即 某个字段的值为null时不会被统计进去。

- **执行效率**
  
  innoDB引擎：count(列名)<count(1)=count(*)**
  
  MyISAM引擎：count(列名)<count(1)<=count(*)
