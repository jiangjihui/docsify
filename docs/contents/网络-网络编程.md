# 网络编程



## BIO、NIO、AIO的区别

> 参考：
>
> - [bio nio aio区别_很多程序猿分不清楚BIO、NIO、AIO的区别](https://blog.csdn.net/weixin_32120857/article/details/113046862)
>- [BIO NIO AIO区别](https://zhuanlan.zhihu.com/p/112810033)

### BIO

BIO 就是传统的 [java.io](http://java.io/) 包，它是基于流模型实现的，交互的方式是**同步、阻塞**方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。

该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就**死-掉-了**。

> BIO主要的问题在于每当有一个新的客户端请求接入时，服务端必须创建一个新的线程来处理这条链路，在需要满足高性能、高并发的场景是没法应用的(大量创建新的线程会严重影响服务器性能，甚至罢工)



### NIO

**简介**

NIO 是 Java 1.4 引入的 java.nio 包，可以构建多路复用的、**同步非阻塞** IO 程序。

它由三个核心部分组成，分别是Buffer（缓冲区）、Channel（通道）、Selector（选择器），可以简单的理解为：Buffer是存储数据的地方，Channel是运输数据的载体，而Selector用于检查多个Channel状态的变更情况。

非阻塞I/O 不管是否有获取到数据，都会立马获取结果，如果没有获取数据的话、那么就不间断的**轮询**重试，但是我们整个应用程序不会实现阻塞。

对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的(网络)应用，应使用NIO的非阻塞模式来开发。





**缓冲区 Buffer**

Buffer是一个对象，包含一些要写入或者读出的数据。

在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。

缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。

具体的缓存区有这些：ByteBuffer、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。



**通道 Channel**

我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。

底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。

Channel主要分两大类：

- SelectableChannel：用户网络读写
- FileChannel：用于文件操作



**选择器 Selector**

Selector是Java NIO 编程的基础。

Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。

一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。



### AIO

AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了**异步非堵塞的 IO** 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

异步的套接字通道是真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O(AIO)。他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。



### 举例

AIO 是彻底的异步通信。
NIO 是同步非阻塞通信。
有一个经典的举例。烧开水。
假设有这么一个场景，有一排水壶（客户）在烧水。

- AIO的做法是，每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。
- NIO的做法是，叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。
- BIO的做法是，叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。





