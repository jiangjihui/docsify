## 设计原则

**尽可能使用 not null**

非null字段的处理要比null字段的处理高效些！且不需要判断是否为null。

null在MySQL中，不好处理，存储需要额外空间，运算也需要特殊的运算符。如select null = null和select null <> null（<>为不等号）有着同样的结果，只能通过is null和is not null来判断字段是否为null。

如何存储？MySQL中每条记录都需要额外的存储空间，表示每个字段是否为null。因此通常使用特殊的数据进行占位，比如int not null default 0、string not null default ‘’

**复合索引只对第一个字段有效**

建立复合索引：

```sql
alter table person add index(first_name,last_name);
```

其原理就是将索引先按照从first_name中提取的关键字排序，如果无法确定先后再按照从last_name提取的关键字排序，也就是说该索引表只是按照记录的first_name字段值有序。

因此select * from person where first_name = ?是可以利用索引的，而select * from person where last_name = ?无法利用索引。

 

 

## 多表[查询](https://www.cnblogs.com/fnlingnzb-learner/p/6343828.html)

**内连接：内连接是子运用比较运算符设置连接条件，只返回满足连接条件的数据行，是将交叉连接生成的结果集按照连接条件进行筛选后形成的。**

内连接（INNER JOIN）：有两种，显式的和隐式的，返回连接表中符合连接条件和查询条件的数据行。（所谓的链接表就是数据库在做查询形成的中间表）

例如：下面的语句3和语句4的结果是相同的。

**语句3：隐式的内连接，没有INNER JOIN，形成的中间表为两个表的笛卡尔积。**

```sql
SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME
FROM CUSTOMERS C,ORDERS O
WHERE C.ID=O.CUSTOMER_ID;
```

**语句4：显示的内连接，一般称为内连接，有INNER JOIN，形成的中间表为两个表经过ON条件过滤后的笛卡尔积。**

```sql
SELECT O.ID,O.ORDER_NUMBER,C.ID,C.NAME
FROM CUSTOMERS C INNER JOIN ORDERS O ON C.ID=O.CUSTOMER_ID;
```

 自然连接（NATURAL INNER JOIN）也属于内连接：与等值连接（隐式内连接）相同，都是在连接条件中使用比较运算符，但结果集中不包括重复字段。（这种连接查询没有存在的价值。因为：自然连接无需指定连接列，SQL会检查两个表中是否相同名称的列，且假设他们在连接条件中使用，并且在连接条件中仅包含一个连接列。不允许使用ON语句，不允许指定显示列，显示列只能用*表示（ORACLE环境下测试的）。对于每种连接类型（除了交叉连接外），均可指定NATURAL。）

 等值连接：R.A=S.A

| R.A  | B    | C    | S.A  | D    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 1    | 2    |

自然连接：R NATURAL INNER JOIN S

| R.A  | B    | C    | D    |
| ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 2    |





## **SQL函数**

**length()**

```sql
-- 查询字段长度=1的数据
select * from table where length(column)=1;
```

 

**replace()**

```sql
-- 替换
update table set column=replace(column,'我','*')
```



**IF表达式**

```sql
IF(expr1,expr2,expr3)
```

> 如果 expr1 是**TRUE** (expr1 <> 0 and expr1 <> NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。



**count()**

COUNT() 函数返回匹配指定条件的行数。COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目。

```sql
SELECT COUNT(DISTINCT column_name) FROM table_name;
```





## **空值比较**

<>'' 和 <>' ' 对于不同数据库是不一样的，在oracle数据库中，<>''查询不到数据，除非跟上 or ... is not null



 

## **IN和EXISTS效率详解**

```sql
select * from T1 where exists(select 1 from T2 where T1.a=T2.a);
```

T1数据量小而T2数据量非常大时，T1<<T2

```sql
select * from T1 where T1.a in (select T2.a from T2);
```

T1数据量非常大而T2数据量小时，T1>>T2

 

 

## **关系数据库事务的ACID特性**

**原子性（Atomicity）：**

即事务是数据库的不可分割单元，事务内的操作要么全部执行完成，如果有一个失败，则事务内的操作全部失败。

**一致性（consistency）：**

即事务必须使数据库从一个一致性状态变成另外一个一致性状态，原子性和一致性是密切相关的。

**隔离性（isolation）：**

即事务和事务之间没有影响关系，这个事务的执行不能被其它事务所干扰。并发执行的各个事务不能互相干扰，具有隔离性。

**持久性（durability）：**

如果事务对数据库进行了操作并进行了提交，则数据库对此的改变应该具有持久性，不能因为其它操作或者数据库的损坏而丢失数据。故事务应该具有持久性。

 

 

## **事务的**[**隔离级别**](https://blog.csdn.net/u012012621/article/details/50787576)

1. **读未提交**

   在该隔离级别，所有事务都可以看到其它事务未提交的内容数据，此隔离级别没有解决任何并发问题，故在应用场景中不常用。

2. **读已提交**

   在该隔离级别，一个事务只能读取其它事务已经提交的内容数据，此隔离级别解决了脏读，但没有解决不可重复读和幻读，是**ORACLE**的默认隔离级别。

3. **可重复读**

   在该隔离级别，能保证一个事务之间的多个实例在并发能读取同一数据，此隔离级别解决了脏读和不可重复读，是**MYSQL**的默认级别。

4. **串行化**

   这是最高的隔离级别，在此隔离级别，事务事务之间只能顺序执行，使之没有任何冲突，也就 是从而解决了脏读，不可重复读和幻读，此隔离级别效率较慢，并且有较多的超时现象。

**事物的隔离级别用以解决在并发的情况下，事务产生的以下问题：**

**更新丢失：**

两个事务都对同一行数据进行更新，但是第二组事务因为某种原因而中途即退出，所以导致两个事务对数据的修改都失败。

**脏读：**

一个事务读取了另一个事务没有提交的数据叫做脏读。例如，A事务正在修改数据，但是还没有修改完毕进行提交，这个过程中B事务对这条数据进行了读取操作，B事务产生了脏读。

**不可重复读：**

一个事务在对数据库进行了再次查询操作，但是即产生了不同结果，数据本身产生了变化，此为不可重复读。例如，A事务第一次查询此条数据，而B事务对此条数据进行了修改，而后A事务又再次查询了此条数据，却不是预期的结果，不能重复读取。故不可重复读（进行了UPDATE操作）。

**幻读：**

一个事务在对数据库进行了再次查询操作，但是却产生了不同结果，或是少了数据行，或是多了未知数据行，此为幻读（一定要明白是数据条数，不是数据本身）。例如，A事务第一次查询此条数据，而B事务对此表进行了插入或者删除操作，而后A事务又再次查询了此表，却产生了与上次不一样的条数记录。故为幻读（进行了INSERT/DELETE操作）。

 

 

## **聚集索引与非聚集索引**

[索引](https://www.cnblogs.com/s-b-b/p/8334593.html)是关系型数据库中给数据库表中一列或多列的值排序后的存储结构，SQL的主流索引结构有B+树以及Hash结构，聚集索引以及非聚集索引用的是B+树索引。这篇文章会总结SQL Server以及MySQL的InnoDB和MyISAM两种SQL的索引。

SQL Sever索引类型有：唯一索引，主键索引，聚集索引，非聚集索引。

MySQL 索引类型有：唯一索引，主键（聚集）索引，非聚集索引，全文索引。

**聚集（clustered）索引**：也叫聚簇索引。数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。

**非聚集（****unclustered****）索引**：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。

 

在[SQL Server](https://www.etuan.com/zx/116-144049.html)中，数据是按页进行存放的。而为表加上聚集索引后，SQL Server对于数据的查找就是按照聚集索引的列作为关键字进行了。因此对于聚集索引的选择对性能的影响就变得十分重要了。本文从旨在从性能的角度来谈聚集索引的选择，但这仅仅是从性能方面考虑。对于有特殊业务要求的表，则需要按实际情况进行选择。聚集索引所在的列或列的组合最好是唯一的 这个原因需要从数据的存放原理来谈。在SQL Server中，数据的存放方式并不是以行(Row)为单位，而是以页为单位。因此，在查找数据时，SQL Server查找的最小单位实际上是页（页的大小是8K）。也就是说即使你只查找一行很小的数据，SQL Server也会将整个页查找出来，放到缓冲池中。

 

 

## **30种SQL语句**[**优化**](https://zhuanlan.zhihu.com/p/72071609)

1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

2.应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

3.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描