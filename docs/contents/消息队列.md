# 消息队列

## 常见消息队列

| 特性  | Kafka                               | RocketMQ                   | ActiveMQ                                 | RabbitMQ                         |
| --- | ----------------------------------- | -------------------------- | ---------------------------------------- | -------------------------------- |
| 吞吐量 | 高吞吐量，可达 10w 级别                      | 高吞吐量，可达 10w 级别             | 1w 级别，吞吐量相交比较低                           | 1w 级别，吞吐量相交比较低                   |
| 时效性 | 延迟在 ms 级                            | 延迟在 ms 级                   | 延迟在 ms 级                                 | 延迟在微妙级，延迟最低                      |
| 可用性 | 天然的分布式系统，数据有副本机制，可用性非常高             | 分布式架构，可用性非常高               | 主从架构，可用性较高                               | 同 ActiveMQ                       |
| 维护性 | 基于 Java 和 Scala 语言 实现，社区活跃度高，维护成本较低 | 基于 Java 语言实现，社区活跃度高，维护成本较低 | 基于 Java 语言实现，消息队列场景功能很完备，但社区活跃度较低，维护成本较高 | 基于 erlang 语言开发，社区活跃度一般，小团队维护成本较高 |

**Kafka是如何做到高吞吐量的？**

Kafka是分布式消息系统，需要处理海量的消息，Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。主要围绕顺序读写、零拷贝、文件分段、批量发送和数据压缩几个方面提高吞吐率。

## 解决消息队列（MQ）丢消息

### 生产者环节

- **消息确认机制**
  
  - **事务机制**：在一些 MQ 产品（如 RabbitMQ、RocketMQ）中支持事务，生产者发送消息前开启事务，消息成功被 MQ 接收后再提交事务，如果在发送过程中出现异常则可以回滚事务，从而确保消息不会丢失。
    
    > RocketMQ 支持生产者确认机制，以确保消息在发送过程中不会丢失。RocketMQ 提供了多种方式来确保消息的可靠发送，包括同步发送、异步发送以及事务消息等多种模式。
    > 
    > 1. **同步发送（Sync Send）**
    > 
    > 同步发送是最简单也是最常见的发送方式，生产者发送消息后会等待 Broker 返回确认信息。如果 Broker 成功接收并存储了消息，会返回一个成功响应；如果 Broker 处理失败，会返回一个失败响应。生产者根据返回的结果来判断消息是否发送成功。
    > 
    > 2. **异步发送（Async Send）**
    > 
    > 异步发送可以提高生产者的吞吐量，因为它不需要等待 Broker 的确认就可以继续发送下一条消息。生产者可以注册一个回调函数，在 Broker 确认消息后调用该回调函数。
    > 
    > 3. **事务消息（Transaction Message）**
    > 
    > 事务消息是 RocketMQ 提供的一种特殊的发送方式，用于确保消息发送的最终一致性。生产者在发送消息之前会先发送一个半消息（Half Message），然后根据业务逻辑来决定是提交还是回滚这条消息。如果提交，消息会被确认；如果回滚，消息会被丢弃。
  
  - **确认机制（ACK）**：大多数 MQ 都提供了消息确认机制，例如 Kafka 的 ack 参数。生产者发送消息后，MQ 会返回一个确认信号给生产者，生产者接收到确认信号后才认为消息发送成功，否则可以进行重发。

- **消息持久化**
  
  - 确保生产者发送的消息在本地进行持久化存储，在发送失败时可以重新读取并发送消息。比如在写入消息队列前先将消息保存到本地磁盘文件或者数据库中。

### MQ 中间件环节

- **持久化配置**
  - **消息存储**：将 MQ 中的消息持久化到磁盘等存储介质上。例如在 RabbitMQ 中，可以将队列设置为持久化，这样即使 MQ 服务重启，消息也不会丢失；Kafka 本身就是基于磁盘存储来设计的，它将消息存储在磁盘上的日志文件中。
  - **元数据存储**：除了消息本身，MQ 的相关元数据（如队列信息、偏移量等）也需要进行持久化。
- **集群部署**
  - 通过构建 MQ 集群可以提高 MQ 的可用性和可靠性。当其中一个节点出现故障时，其他节点可以继续处理消息，确保消息不会丢失。例如在 RabbitMQ 中可以搭建主从模式的集群，Kafka 本身就是分布式的消息队列，通过多个 broker 组成集群。

### 消费者环节

- **手动确认机制**
  - 消费者在成功处理完消息后才向 MQ 发送确认信号，这样可以确保消息不会因为消费者在处理过程中出现异常而丢失。例如在 RabbitMQ 中，消费者可以设置为手动确认模式，在业务逻辑处理完成后调用确认方法；Kafka 消费者在处理完一批消息后提交偏移量来确认消息的消费。
- **消息补偿机制**
  - 当消费者处理消息失败时，可以将失败的消息放入一个补偿队列或者存储到数据库中，然后进行重试或者人工处理。例如，设置一个专门的重试队列，将处理失败的消息放入该队列，按照一定的策略（如延迟一段时间后）重新进行消费。



## Kafka和RocketMQ的区别

### 架构

#### 集群管理方式不同

这2个mq都是集群方式部署，节点之间需要相互通信，所以都需要进行集群信息的管理，Kafka使用**Zookeeper**，而RocketMQ使用**NameServer**更轻量。

- RocketMQ是国产自研的消息队列，参考了Kafka的设计思想，但做了一些调整。RocketMQ在架构上做了减法，去掉了Zookeeper，使用NameServer管理集群信息，简化了分区管理，用更轻量的方式管理消息队列的集群信息。

- 后期Kafka也支持移除Zookeeper，通过broker之间加入一致性算法Raft实现同样的效果。Kafka从2.8版本开始引入了KRaft模式，允许用户在不需要Zookeeper的情况下运行Kafka集群，并且Kafka 4.0及以后的版本可能会完全移除对Zookeeper的依赖，但在当前及之前的版本中，Zookeeper仍然扮演着重要的角色，用于存放元数据、管理集群成员和选举Controller等。

#### 分区实现不同

Kafka会将topic拆分为多个**Partition**（分区），通过增加分区数量，可以处理更多的消息吞吐量。如果一个分区出现故障，其他分区仍然可以继续工作，不会影响整个 topic 的可用性。同时，Kafka 可以通过副本机制来保证分区数据的可靠性。

- Partition存储完整的消息体

- Partition由segment组成，当topic过多之后，topic底下的Partition分区也会变多，对应Partition底下的segment文件也会变多，在同时写多个topic底下的Partition就是同时写多个文件，虽然每个文件内部都是顺序写，但多个文件存在磁盘的不同地方，原本顺序写磁盘就可能劣化成随机写，于是写性能就降低了。

RockMQ也将topic拆分为多个**Queue**（分区），只存储简要信息，比如消息偏移offset，消息的完整数据则放到一个叫**commit log**的文件上。

- Queue只存储一些简要信息

> Kafka读取消息只需要读取一次，而RocketMQ需要先到Queue上读取offset，再去commit log上将完整数据读取出来。

- rocketMQ将单个broker底下的多个topic数据全部写到一个逻辑文件 commit log 上，消除了Kafka随机写多文件的问题。将所有写操作都变成了**顺序写**。提升了rocketMQ在多topic场景下的写性能。

#### 备份模型不同

- Kafka的主从同步以Partition为单位，每个broker底下有多个Partition。

- 而RocketMQ以broker为单位区分主从，相比Kafka备份模型更简单。

#### RocketMQ增加的功能

- **消息过滤**
  
  rocketmq支持对消息打tag，消费者能根据tag过滤所需要的数据。

- **支持事务**

- **延时队列**

- **死信队列**


