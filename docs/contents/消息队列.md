# 消息队列

## 常见消息队列

| 特性  | Kafka                               | RocketMQ                   | ActiveMQ                                 | RabbitMQ                         |
| --- | ----------------------------------- | -------------------------- | ---------------------------------------- | -------------------------------- |
| 吞吐量 | 高吞吐量，可达 10w 级别                      | 高吞吐量，可达 10w 级别             | 1w 级别，吞吐量相交比较低                           | 1w 级别，吞吐量相交比较低                   |
| 时效性 | 延迟在 ms 级                            | 延迟在 ms 级                   | 延迟在 ms 级                                 | 延迟在微妙级，延迟最低                      |
| 可用性 | 天然的分布式系统，数据有副本机制，可用性非常高             | 分布式架构，可用性非常高               | 主从架构，可用性较高                               | 同 ActiveMQ                       |
| 维护性 | 基于 Java 和 Scala 语言 实现，社区活跃度高，维护成本较低 | 基于 Java 语言实现，社区活跃度高，维护成本较低 | 基于 Java 语言实现，消息队列场景功能很完备，但社区活跃度较低，维护成本较高 | 基于 erlang 语言开发，社区活跃度一般，小团队维护成本较高 |

**Kafka是如何做到高吞吐量的？**

Kafka是分布式消息系统，需要处理海量的消息，Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。主要围绕顺序读写、零拷贝、文件分段、批量发送和数据压缩几个方面提高吞吐率。



## 解决消息队列（MQ）丢消息

### 生产者环节

- **消息确认机制**
  - **事务机制**：在一些 MQ 产品（如 RabbitMQ、RocketMQ）中支持事务，生产者发送消息前开启事务，消息成功被 MQ 接收后再提交事务，如果在发送过程中出现异常则可以回滚事务，从而确保消息不会丢失。
    
    > RocketMQ 支持生产者确认机制，以确保消息在发送过程中不会丢失。RocketMQ 提供了多种方式来确保消息的可靠发送，包括同步发送、异步发送以及事务消息等多种模式。
    > 1. **同步发送（Sync Send）**
    > 
    > 同步发送是最简单也是最常见的发送方式，生产者发送消息后会等待 Broker 返回确认信息。如果 Broker 成功接收并存储了消息，会返回一个成功响应；如果 Broker 处理失败，会返回一个失败响应。生产者根据返回的结果来判断消息是否发送成功。
    > 
    > 2. **异步发送（Async Send）**
    > 
    > 异步发送可以提高生产者的吞吐量，因为它不需要等待 Broker 的确认就可以继续发送下一条消息。生产者可以注册一个回调函数，在 Broker 确认消息后调用该回调函数。
    > 
    > 3. **事务消息（Transaction Message）**
    > 
    > 事务消息是 RocketMQ 提供的一种特殊的发送方式，用于确保消息发送的最终一致性。生产者在发送消息之前会先发送一个半消息（Half Message），然后根据业务逻辑来决定是提交还是回滚这条消息。如果提交，消息会被确认；如果回滚，消息会被丢弃。
  - **确认机制（ACK）**：大多数 MQ 都提供了消息确认机制，例如 Kafka 的 ack 参数。生产者发送消息后，MQ 会返回一个确认信号给生产者，生产者接收到确认信号后才认为消息发送成功，否则可以进行重发。
- **消息持久化**
  - 确保生产者发送的消息在本地进行持久化存储，在发送失败时可以重新读取并发送消息。比如在写入消息队列前先将消息保存到本地磁盘文件或者数据库中。

### MQ 中间件环节

- **持久化配置**
  - **消息存储**：将 MQ 中的消息持久化到磁盘等存储介质上。例如在 RabbitMQ 中，可以将队列设置为持久化，这样即使 MQ 服务重启，消息也不会丢失；Kafka 本身就是基于磁盘存储来设计的，它将消息存储在磁盘上的日志文件中。
  - **元数据存储**：除了消息本身，MQ 的相关元数据（如队列信息、偏移量等）也需要进行持久化。
- **集群部署**
  - 通过构建 MQ 集群可以提高 MQ 的可用性和可靠性。当其中一个节点出现故障时，其他节点可以继续处理消息，确保消息不会丢失。例如在 RabbitMQ 中可以搭建主从模式的集群，Kafka 本身就是分布式的消息队列，通过多个 broker 组成集群。

### 消费者环节

- **手动确认机制**
  - 消费者在成功处理完消息后才向 MQ 发送确认信号，这样可以确保消息不会因为消费者在处理过程中出现异常而丢失。例如在 RabbitMQ 中，消费者可以设置为手动确认模式，在业务逻辑处理完成后调用确认方法；Kafka 消费者在处理完一批消息后提交偏移量来确认消息的消费。
- **消息补偿机制**
  - 当消费者处理消息失败时，可以将失败的消息放入一个补偿队列或者存储到数据库中，然后进行重试或者人工处理。例如，设置一个专门的重试队列，将处理失败的消息放入该队列，按照一定的策略（如延迟一段时间后）重新进行消费。


